https://bigfloat.readthedocs.io/en/latest/reference/index.html

I forget exactly the format I settled on, but the key operations I want are:

String conversions:
  - Convert from decimal or hex string to (correctly rounded) float
  - Convert from float to hex string (with appropriate precision for the type)
  - Convert from float to decimal string (correctly rounded, with limited
    precision)
  - Convert from float to decimal string (exact, with as many digits as
    necessary but ideally no more)

Bit conversions:
  - Extract sign, exponent, and mantissa from a FP value, as they would be
    stored in the type being shown (so exponent with bias, mantissa with or
    without leading bit depending on whether this is the Intel 80-bit format,
    subnormals as... subnormals)
  - Convert a triple (s, e, m) to a FP value (again, as they'd be represented
    in the format)

Believe I can do all of these things with bigfloat and a little knowledge about
the IEEE representations.

  - Decimal string to float:
        BigFloat.exact(string, context)
  - Hex string to float:
        BigFloat.fromhex(string, context)
  - Float to hex:
        myBigFloat.hex() works, but doesn't normalize the way I want. May want
        to hack this up myself after I extract the mantissa/exponent?
  - Float to decimal (rounded):
        str(myfloat) works, but doesn't give control over the precision
        "{:.60g}".format(myfloat) or similar if you want a specific precision
  - Float to decimal (exact):
        "{:.1000g}".format(myfloat)
            or some sufficiently large number for the type

  - Extract exponent:
        floor(log2(myfloat)) TODO check boundary conditions for this
  - Extract mantissa:
        myfloat * pow(2, -expo + num_mant_bits)
            give or take an off-by-one error somewhere
            TODO subnormals, but I'm sure I can implement those by hand
  - Extract sign:
        copysign(1, myfloat)
  - Convert (s, e, m) to float:
        s * m * pow(2, e)
            give or take whether e is biased and whether m includes leading 1



Cool features to implement:
  - Special options for edge-case constants: max norm, min norm, min subnorm.
    Check the others from float.h to see if some are useful. (Epsilon??)
      - For that matter, if the input is one of those constants, maybe print
        the name?
            ### INPUT HEX: 0x1.fffffep+127
            Dec (approx): 3.40282347e+38
            Hex (%a):     0x1.fffffep+127
            int10 * ULP:  16777215 * 2**104
            float.h name: FLT_MAX
            fpclassify:   FP_NORMAL
            Bits (hex):   0x7f7fffff
            Bits (bin):   0 11111110 11111111111111111111111
        I guess in that case we should accept "FLT_MAX" as input.
          - Which saves some weird reordering difficulties that would arise if
            I had a --flt_max, since I'm now hacking up the args before
            argparse gets to them.
          - Also, I guess showfloat.py -d FLT_MAX is valid, but maybe give a
            warning if printing a constant in a different format?
  - Option for "print out the parameters of this floating-point format". Exp
    bits, mant bits (stored and w/ leading?), exponents of FLT_MAX FLT_MIN
    FLT_SUB_MIN, exponent bias.
